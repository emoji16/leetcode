# 排序

[TOC]

## 库函数：C-qsort，C++-sort

## 选择排序：O(n^2)|O(1)

时间复杂度O(n*(n-1)/2) = O(n^2)

空间复杂度O(1)

```C++
void selectionSort (vector<int> &nums){
    int n = nums.size();
	for(int i = 0;i < n - 1;i++){
		int k = i；
		for(int j = i + 1;j < n;j++){
			if(nums[j] < nums[k]){
				k = j
			}
		}
		swap(nums[k],nums[i]);//可以省去k，i相等的判断，省去一次判断步骤
	}
}
```

## 冒泡排序：O(n^2)|O(1)

最坏时间复杂度O(n*(n-1)/2) = O(n^2)

空间复杂度O(1)

```C++
void bubbleSort (vector<int>& nums) {
        bool swapped;
    	int n = nums.size();
        for(int i = 0;i < n - 1;i++){
            swapped = false;
            for(int j = 0; j < nums.size() - 1 - i;j++){
                if(nums[j] >= nums[j + 1]){
                    swap(nums[j],nums[j+1]);
                    swapped = true;
                }
            }
            if(!swapped) break;
        }
    }
```

## 插入排序：O(n^2)|O(1)

```C++
void insertionSort (vector<int> &nums){
    int n = nums.size();
	for(int i = 1;i < n;i++){
        int tmp = nums[i],j = i - 1;
        while(j >= 0 && tmp < nums[j]){
            nums[j + 1] = nums[j];
            j--;
        }
        nums[j] = tmp
    }
}
```

## 归并排序：O(nlogn)|O(n)

```C++
void mergeSort (vector<int> & nums, int l, int r, vector<int> &tmp){
	//左闭右开区间
    if(l + 1 >= r) return;
    //divide
	int m = l + （l - r)/2;//mid标准写法
	mergeSort(nums,l,m,tmp);//mid写到哪边都一样
	merge(nums,m,r,tmp);
	//merge
    int p = l,q = m,i = l;
    while(p < m || q < r){
        if(q >= r || p < m && q < nums[p] <= nums[q]){
            tmp[i++] = nums[p++];
        }
        else{
            tmp[i++] = nums[q++];
        }
    }
    for(i = l;i < r;i++){
        nums[i] = tmp[i];
    }
}
```

## 快速排序：O(nlogn)|O(1)

最坏时间复杂度O(n^2)//倒序：需要提前打乱

平均时间复杂度O(nlogn)

```c++
void quickSort(vector<int> & nums, int l, int r){
    //左闭右开
    if(l + 1 >= r) return;
    int first = l,last = r - 1,key = nums[first];
    while(first < last){
        while(first < last && nums[last] >= key){
            --last;
        }
        nums[first] = nums[last];/或者swap
        while(first < last) && nums[first] <= key){
            ++first;
        }
        nums[last] = nums[first];
    }
	nums[first] = key;
    quickSort(nums,l,first);
    quickSort(nums,first,r);
}
```

* 应用：**快速选择**，找到第k大/小的元素：平均O(n)，最坏O(n^2)

## 桶排序

桶排序：为每个值设立一个桶，桶内记录这个值出现的次数；然后用这个桶排序

personal：类似于hash将变量值转换为数组下标；这里将**统计量作为数组下标**（这样就自然有序）

利用数组下标快的特点

详见例子前k高频371，O(nlogn) ->O(n)