# 算法笔记Chapter4-基础算法和技巧

[TOC]

## 散列/哈希hash

* 实现：map/unordered_map
* 把元素（key）转换（散列函数H）为整数（唯一标识），然后把这个整数用作**数组下标**进行操作

* 一种空间换时间策略：主要利用数组下标可直接访问!

* 散列函数：
  * 直接定址（原数/线性变换）
  * 平方取中（平方值中间若干位）
  * 除留余数（%mod -mod素数）

* 冲突处理：开放定址（对应位置被占用的时候新位置计算开放定址）/链地址法
  * 线性探查法
  * 平方探查法
  * 链地址法
* 字符串hash: 转化为26/52/62进制数/拼接（方法不限，只要能唯一标识即可）

​	

## 分治与递归

* 分治:
  * **分解**为不重叠的子问题
  * **解决**子问题（常递归思想解决，但非必须）
  * **合并**子问题的解
  
* 分治 VS 减治
  * 减治 decrease and conquer：子问题数为1
  * 分治divide and conquer：子问题数大于1
  
* 分治 VS 动态规划
  * 分治：解决**不重叠**的子问题。思想：从上到下的划分然后合并
    * 遇到F(n) = F(n-1)+F(n-2)这种F(n-1)与F(n-2)都固定值不是动态相关+有重复计算的问题可以结合memoization(记忆化搜索：保存中间结果）技术优化
  * 动态规划：解决**重叠**子问题，思想从下至上
    * 从下至上计算F(n) = F(n-1)+F(n-2)
  
* 递归

  * 对于无头绪的排列组合问题，可以思考最简单暴力的方法遍历所有可能方法（详见算法笔记全排列问题，n皇后问题）。过程中可以使用hashtable记录已经作出的决策，每种可能遍历完恢复hashtable即可。

    可结合回溯剪提高效率。

#### 模板1：递归遍历+剪枝回溯 --解决全排列/n皇后问题（算法笔记P115)



## 贪心

* 适用于满足**最优子结构**（即一个问题的最优解可以由子问题的最优解构造出来）的最优化问题

* 严谨过程：想到策略，反证（假设策略不能导致最优解）证明策略正确性，数学归纳法证明全局最优

  一般过程：自己想好就试一试...

* 区间贪心

个人小结：贪心--将全局最优问题转化为满足局部限制即可。