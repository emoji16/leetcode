# 基本数据结构

[TOC]

## 链表ListNode

```c++
struct ListNode {
	int val;
	ListNode *next;
	ListNode(int x) : val(x), next(nullptr) {}
};
```

* 防止内存出错tips：

  * tip1：尽量**处理当前节点的下一个节点**而非当前节点本身
  * tip2：建立一个**虚拟节点 (dummy node)**，使其指向当前链表的头节点，这样即使原链表所有节点全被删除，也会有一个 dummy 存在，返回 dummy->next 即可。（统一所有节点，不用单独考虑头结点操作）
  
* tip3：可用**快慢指针**找到中点和结尾或者其他操作。eg.fast/slow+left/right找中点，归并排序/几何关系/最后n个等。快慢指针找中点的时候考虑**len = 1/2**等的极限情况。

  

## 树TreeNode

```c++
struct TreeNode {
	int val;
	TreeNode *left;
	TreeNode *right;
	TreeNode(int x) : val(x), left(NULL), right(NULL) {}
};
```

* tip1：结合dfs**写辅函数递归处理，能写出优雅的代码**
* bfs
* dfs
  * **前序遍历**：前序遍历的迭代实现可以stack简单解决
  * **中序遍历**：每个节点遍历一次
  * **后序遍历**
* tip2:注意**删除节点尾指针**要处理好。
* tip3:ListNode,TreeNode都是删除后最好**delete**指针
* tip4：考虑**没有子树/只有左子树/只有右子树**的情况

### * 二叉查找树BST

**实现**class BST：对树封装struct Node+Node* root+makeEmpty/insert/find/remove--findMin/findMax）

* tip1：用辅函数递归
* tip2：利用中序遍历结果**有序**！勿忘利用本身的**排列关系！！**
* tip3：此时记录前一个用TreeNode* prev 不用int，省着二次遍历！

```c++
template <class T>
class BST{
	struct Node{
		T data;
		Node* left;
		Node* right;
	};
	Node* root;
	Node* makeEmpty(Node* t){//这里要清理内存
		if(t == NULL) return NULL;
        makeEmpty(t->left);
        makeEmpty(t->right);
        delete t;
        return NULL;
	}
    Node* insert(Node* t,T x){
        if(t == NULL){
            t = new Node;
            t->data = x;
            t ->left = t->right=NULL;
        }else if(x < t->data){
            t->left = insert(t->left,x);
        }else if(x > t->data){
            t->right = insert(t->right,x);//这里写法没有包含等于，不包含重复元素
        }
        return t;
    }
    Node* find(Node* t,T x){//可以是find，也可以是找到insert的位置
        if(t == NULL) return NULL;
        if(x < t->data) return find(t->left,x);
        if(x > t->data) return find(t->right,x);
        return t;
    }
    Node findMin(Node* t){
        if(t == NULL||t->left == NULL) return t;
        else findMin(t->left);
    }
    Node findMax(Node* t){
        if(t == NULL||t->right == NULL) return t;
        else findMax(t->right);
    }
    Node* remove(Node* t,T x){
        if(t == NULL) return NULL;
        else if(x < t->data) t->left = remove(t->left,x);
        else if(x > t->data) t->right= remove(t->right,x);
        else if(t->left&&t->right){
            //需要找到左面最大或右面最小,可以写成单独函数，也可以不单独写出去
            Node* tmp = findMin(t->right);
            t->data = tmp->data;
            t->right = remove(t->right,t->data)
        }else{
            Node* tmp = t;//注意在这里回收就可以了
            if(t->left == NULL) t = t->left;
            else t = t->right;
            delete tmp;
        }
    }
    public:
    	BST():root(NULL){}
    	~BST(){
            root = makeEmpty(root);
        }
    void insert(T x){
        insert(root,x);//调用递归辅函数
    }
    void remove(T x){
         remove(root,x);
    }
    //find
}
```



### * 字典树/前缀树Trie

作用：判断字符串是否存在或者是否具有某种字符串前缀，高效检索字符串数据集，可应用于自动补完和拼写检查。边对应字母，叶子节点对应单词。

> 由于一个英文单词的长度 n 通常在 10 以内，如果我们使用字典树，则可以在 O(n)——近似 O(1)
> 的时间内完成搜索，且额外开销非常小。

数据结构设计class TrieNode+Trie设计与实现查看leetcode208：把握住边是字母，即root无意义，往下每个节点的bool代表这个有这个字母

**实现：**

class TrieNode（bool-用来标记是否有已完结的单词+TrieNode*[26])

classTrie（TrieNode*+starts with/insert/search等方法）

## 图Graph

* 性质

  * 有向图 vs 无向图：directed vs undirected

  * 循环 vs 无循环：cyclic vs acyclic

  * 所有节点相连 vs 不相连：connected vs disconnected

    eg.树-相连的无向无环图，有向无环图DAG

* 表示

  * 邻接链表adjacency list
* 邻接矩阵adjacency matrix
  * 边缘列表-m*2矩阵存储所有边（m为边数）

PS:可以使用indegree数组统计图的特性

### * 二分图

> 定义1：二分图算法也称为染色法，是一种广度优先搜索bfs。如果可以用两种颜色对图中的节点进行着
> 色，并且保证相邻的节点颜色不同，那么图为二分。leetcode 785
>
> 定义2：  如果能将一个图的节点集合分割成两个独立的子集 `A` 和 `B` ，并使图中的每一条边的两个节点一个来自 `A` 集合，一个来自 `B` 集合，就将这个图称为 **二分图** 。



### * 拓扑排序

leetcode210：可以使用**bfs+visit数组**；也可以用**indegree数组**！！！从indegree==0的开始！

